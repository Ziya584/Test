<?php


	/**
	Тестовое задание для PHP программиста
	Написать функцию, реализующую бинарный поиск значения по ключу в текстовом файле.
	Аргументы: имя файла, значение ключа
	Результат: если найдено: значение, соответствующее ключу, если не найдено: undef
	Исходные данные и требования к реализации:
	1. Объем используемой памяти не должен зависеть от размера файла, только от максимального размера записи.
	2. Формат файла: ключ1\tзначение1\x0Aключ2\tзначение2\x0A...ключN\tзначениеN\x0A Где: \x0A - разделитель записей
		(код ASCII: 0Ah) \t - разделитель ключа и значения (табуляция, код ASCII: 09h) Символы разделителей гарантированно
	 	не могут встречаться в ключах или значениях. Записи упорядочены по ключу в лексикографическом порядке с учетом
		регистра. Все ключи гарантированно уникальные.
	3. Ограничений на длину ключа или значения нет.
	Функция на файле размером 10Гб с записями длиной до 4000 байт должна отрабатывать любой запрос менее чем за 5 секунд.
	 */


	/*
	Задание: написать скрипт который будет искать значение по ключу из данных полученных из обычного текстового файла.
	Реализовать поиск методом бинарного поиска.
	Бинарный поиск как я понимаю это если каждый раз делить по полам и отбросить не нужную часть.
	Допустим если мы ищем число 30 среи цифр от 0го до 100, то сначала делим 100 по полам и получаем 50.
	Потом проверяем в какой половине нахидится искомое значение. т.к. 30 меньше 50ти, мы уже не ищем в диапазоне 50-100,
	потом 50 делим по полам и получаем 25, получается искомое значение между 25 и 50, поэтому мы прибавляем 25 на 50
	и опять делим по полам. Получается 37,5, если округлим то получается 38. Т.к. до этой операции мы выяснили,
	что искомое значение больше, чем 25, следовательно сейчас мы рассмотрим интервал от 25 до 38. т.е. 25+38=63 далее 63/2 = 31,5.
	25+32=57 57/2=28,5 29:31
	29+31=60 60/2=30
	*/


	define('ROOT', dirname(__FILE__)); //определяем константу для корневой дирректории

	function binarySearchByKey($file, $iskomoye_znacheniye){
		$handle = fopen($file, "r"); //открываем файл для чтения
		while (!feof($handle)) { // пока не наступит конец файла
			$string = fgets($handle,4000); // читаем данные по 4000 байт
			mb_convert_encoding($string, 'cp1251'); // чтобы русские буквы не выглядели как кракозябры
			$explodedstring = explode('\x0A', $string); // получается массив ключ\tзначение
			// echo "<pre>";
			// print_r($explodedstring);
			array_pop($explodedstring); // удаляем последний элемент массива т.к. он получается пустым
			foreach ($explodedstring as $key => $value) {
				$arr[] = explode('\t', $value);// получаем массив в массиве, где ключ и значение отдельные элементы
			}
			// echo "<pre>";
			// print_r($arr); // смотрим на результат массива
			$nachalo = 0; // задаем начальное значение
			$konec = count($arr)-1; // определяем конец. т.к. нулевой массив считается первым элементом вычитываем единицу

			while ($nachalo <= $konec) { // цикл работает пока начальное значение не превышает или не становится равным конечной
				$poluchennaya_seredina = floor(($nachalo + $konec) / 2); // определяем середину и округляем сразу же
				$strnatcmp = strnatcmp($arr[$poluchennaya_seredina][0],$iskomoye_znacheniye); // сравниваем полученное с искомым

				if ($strnatcmp > 0) {
					$konec = $poluchennaya_seredina - 1; // присваиваем к конечному значению
				} elseif ($strnatcmp < 0) {
					$nachalo = $poluchennaya_seredina + 1; // присваиваем к начальному значению
				} else {
					return $arr[$poluchennaya_seredina][1]; // возвращаем значение по ключу
				}
			}
		}
		return 'undef'; // в случаем если в файле вообще нет искомого значения
	}


	$iskomoye_znacheniye = 'ключ64'; // дальше наверно всё понятно
	$file = ROOT.'/keynumeric.txt';
	echo binarySearchByKey($file, $iskomoye_znacheniye)."</br>";
	echo "Если искомый ключ не существует в файле: ";
	$iskomoye_znacheniye = 'ключ322';
	echo binarySearchByKey($file, $iskomoye_znacheniye)."</br>";


